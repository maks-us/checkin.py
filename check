#!/usr/bin/env python2
import os
import time
import datetime
import sys
import json
import re


DB = os.path.expanduser('~/hours.json')
DB_HUMAN = os.path.expanduser('~/hours.txt')
HOURS_PER_MONTH = 160

if os.path.exists(DB):
    db = json.load(open(DB))
else:
    db = []


def get_time(t):
    if not t:
        return int(time.time())
    else:
        try:
            dt = datetime.datetime.strptime(t, "%H:%M")
            dt = datetime.datetime.now().replace(hour=dt.hour, minute=dt.minute)
        except ValueError:
            dt = datetime.datetime.strptime(t, "%d.%m.%Y-%H:%M")
        return int(time.mktime(dt.timetuple()))

def convert_argv(argv, result = {}):
		type = argv[0]
		selected_time = None
		message = result.get('message', None)
		if len(argv) == 1:
				result.update({type: get_time(None), 'message': message})
				return result

		time_format = re.compile("^[0-9]{1,2}:[0-9]{2}$")
		datetime_format = re.compile("^[0-9]{1,2}\.[0-9]{2}\.[0-9]{4}\-[0-9]{1,2}:[0-9]{2}$")
		if time_format.match(argv[1]) or datetime_format.match(argv[1]):
				selected_time = get_time(argv[1])

		if len(argv) == 2 and selected_time is None:
				message = argv[1] or message

		if len(argv) == 3:
				message = argv[2] or message

		if selected_time is None:
				selected_time = get_time(None)

		result.update({type: selected_time, 'message': message})
		return result

def checkin(argv):
    if db:
        last_checkin = db[-1]
        assert 'out' in last_checkin, "Already checked in"
    db.append(convert_argv(argv))

def checkout(argv):
    last_checkin = db[-1]
    assert 'in' in last_checkin, "Not yet checked in"
    assert 'out' not in last_checkin, "Already checked out"
    convert_argv(argv, last_checkin)

def nextmonth(m):
    if m == 12:
        return 1
    return m + 1


def save_db():
    json.dump(db, open(DB, 'w'))

    prevmonth = None
    summonth = datetime.timedelta()
    output = []

    total = []

    def format_duration(delta):
        totalseconds = delta.days * 60 * 60 * 24 + delta.seconds
        h, s = divmod(totalseconds, 3600)
        return '%dh %dm' % (h, int(s/60))

    def summary(delta):
        output.append('')
        output.append(' '*25 + 'Total: %s' % format_duration(delta))
        output.append('')
        output.append('')
        total.append(summonth)

    for entry in db:
        checkin_datetime = datetime.datetime.fromtimestamp(entry['in'])

        if 'out' in entry:
            checkout_datetime = datetime.datetime.fromtimestamp(entry['out'])
            line_format = "{checkin} - {checkout} = {duration}  '{message}'"
        else:
            checkout_datetime = datetime.datetime.now().replace(microsecond=0)
            line_format = "{checkin} -  NOW  = {duration}  '{message}'"

        if prevmonth != checkin_datetime.month:
            if prevmonth is not None:
                summary(summonth)
                summonth = datetime.timedelta()
                expected_next_month = nextmonth(prevmonth)
                while expected_next_month != checkin_datetime.month:
                    summary(datetime.timedelta())
                    expected_next_month = nextmonth(expected_next_month)
            output.append(checkin_datetime.strftime('%B %Y'))
            output.append('=' * 20)
            prevmonth = checkin_datetime.month

        summonth += (checkout_datetime - checkin_datetime)
        message = entry.get('message')

        output.append(line_format.format(
            checkin=checkin_datetime.strftime('%a, %d. %b\t%H:%M'),
            checkout=checkout_datetime.strftime('%H:%M'),
            duration=checkout_datetime - checkin_datetime,
            message=message
        ))


    summary(summonth)

    missing = datetime.timedelta(hours=HOURS_PER_MONTH) * len(total) \
              - sum(total, datetime.timedelta())
    output.extend(['Total missing: %s' % format_duration(missing), ''])

    open(DB_HUMAN, 'w').write('\n'.join(output))


def main():
    if len(sys.argv) > 1:
        {'in': checkin, 'out': checkout}[sys.argv[1]](sys.argv[1:])
    save_db()
    print open(DB_HUMAN).read()


main()
